package main

import (
	"context"
	"crypto/tls"
	"flag"
	"github.com/btcsuite/btcd/rpcclient"
	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"github.com/lightningnetwork/lnd/cert"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"log"
	"net"
	"om-rpc-tool/gateway"
	"om-rpc-tool/signal"
	"om-rpc-tool/toolrpc"
	"om-rpc-tool/toolrpc/server"
	"os"
	"path/filepath"
	"time"
)

func main() {
	var omniHost = ""
	var rpcUser = ""
	var rpcPasswd = ""
	var netType = ""
	var certDir = ""
	var enableLuckServer = false
	var lnddir = "false"
	var nodeAddress = "false"
	flag.Set("alsologtostderr", "true")
	flag.StringVar(&omniHost, "omni_host", "localhost:8332", "ip:port")
	flag.StringVar(&rpcUser, "rpc_user", "test", "")
	flag.StringVar(&rpcPasswd, "rpc_passwd", "test", "")
	flag.StringVar(&netType, "net_type", "", "")
	flag.StringVar(&certDir, "cert_dir", "./cert", "tls cert dir")
	flag.BoolVar(&enableLuckServer, "enable_luck_server", false, "tls cert dir")
	flag.StringVar(&lnddir, "lnddir", "", "lnddir contain macaroon-asset for connect oblndNode ")
	flag.StringVar(&nodeAddress, "node_address", "localhost:10001", "oblndNode grpc address")
	flag.Parse()
	// Connect to local namecoin core RPC server using HTTP POST mode.
	connCfg := &rpcclient.ConnConfig{
		Host:         omniHost,
		User:         rpcUser,
		Pass:         rpcPasswd,
		HTTPPostMode: true, // Namecoin core only supports HTTP POST mode
		DisableTLS:   true, // Namecoin core does not provide TLS by default
	}
	// Notice the notification parameter is nil since notifications are
	// not supported in HTTP POST mode.
	client, err := rpcclient.New(connCfg, nil)
	if err != nil {
		log.Fatal(err)
	}
	defer client.Shutdown()
	if netType == "" {
		log.Fatalln("miss net_type")
	}
	if certDir != "" {
		os.MkdirAll(certDir, os.ModePerm)
	}
	shutdownChan, err := signal.Intercept()
	if enableLuckServer {
		if len(lnddir) == 0 {
			log.Fatalln("miss lnddir")
		}
		//grpcs
		lis1, err := net.Listen("tcp", ":38332")
		if err != nil {
			log.Fatalln("Failed to listen:", err)
		}
		tlsCfg := getTlsCfg(certDir)
		tlsCfg.ClientAuth = tls.RequireAnyClientCert
		serverCreds := credentials.NewTLS(tlsCfg)
		serverOpts := []grpc.ServerOption{grpc.Creds(serverCreds),
			grpc.UnaryInterceptor(useridInterceptor),
			grpc.StreamInterceptor(useridInterceptorStream),
		}
		luckServer := toolrpc.NewLuckPkServer(nodeAddress, netType, lnddir, &shutdownChan)
		s1 := grpc.NewServer(serverOpts...)
		toolrpc.RegisterLuckPkApiServer(s1, luckServer)
		log.Println("Serving gRPCs on 0.0.0.0:38332")
		go func() {
			log.Fatalln(s1.Serve(lis1))
		}()
	}

	// Create a listener on TCP port
	lis, err := net.Listen("tcp", ":8080")
	if err != nil {
		log.Fatalln("Failed to listen:", err)
	}
	rserver := server.NewRpc(client, netType)
	// Create a gRPC server object
	s := grpc.NewServer()
	// Attach the Greeter service to the server
	toolrpc.RegisterToolsServer(s, rserver)
	// Serve gRPC Server
	log.Println("Serving gRPCs on 0.0.0.0:8080")
	go func() {
		log.Fatalln(s.Serve(lis))
	}()

	//gw server
	opts := gateway.Options{
		Addr: ":8090",
		GRPCServer: gateway.Endpoint{
			Network: "tcp",
			Addr:    "0.0.0.0:8080",
		},
		OpenAPIDir: "swagger",
	}
	go func() {
		gateway.Run(context.Background(), opts, []func(context.Context, *runtime.ServeMux, *grpc.ClientConn) error{toolrpc.RegisterToolsHandler})
	}()
	<-shutdownChan.ShutdownChannel()

	//sleep 3 second, for some go routine which depend  shutdownChan to complete database op.
	time.Sleep(3 * time.Second)
	log.Println("done shutdown")

	//simpest
	// Create a client connection to the gRPC server we just started
	// This is where the gRPC-Gateway proxies the requests
	//conn, err := grpc.DialContext(
	//	context.Background(),
	//	"0.0.0.0:8080",
	//	grpc.WithBlock(),
	//	grpc.WithTransportCredentials(insecure.NewCredentials()),
	//)
	//if err != nil {
	//	log.Fatalln("Failed to dial server:", err)
	//}
	//
	//gwmux := runtime.NewServeMux()
	//// Register Greeter
	//err = toolrpc.RegisterToolsHandler(context.Background(), gwmux, conn)
	//if err != nil {
	//	log.Fatalln("Failed to register gateway:", err)
	//}
	//
	//gwServer := &http.Server{
	//	Addr:    ":8090",
	//	Handler: gwmux,
	//}
	//
	//log.Println("Serving gRPC-Gateway on http://0.0.0.0:8090")
	//log.Fatalln(gwServer.ListenAndServe())
}

func getTlsCfg(certDir string) *tls.Config {
	certPath := filepath.Join(certDir, "tls.cert")
	keyPath := filepath.Join(certDir, "tls.key")
	if !fileExists(certPath) {
		log.Println("Generating TLS certificates...")
		err := cert.GenCertPair(
			"lnd autogenerated cert", certPath,
			keyPath, nil, nil, true,
			1000*24*time.Hour,
		)
		if err != nil {
			log.Fatalln(err)
		}
		log.Println("Done generating TLS certificates")
	}
	certData, _, err := cert.LoadCert(
		certPath, keyPath,
	)
	if err != nil {
		log.Println("err load TLS certificates")
	}
	//tlsCfg := cert.TLSConfFromCert(certData)
	return &tls.Config{Certificates: []tls.Certificate{certData}}
	//return tlsCfg
}

func fileExists(name string) bool {
	if _, err := os.Stat(name); err != nil {
		if os.IsNotExist(err) {
			return false
		}
	}
	return true
}

func useridInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
	//log.Println("useridInterceptor ", info.FullMethod)
	if info.FullMethod == "/toolrpc.luckPkApi/RegistTlsKey" {
		return handler(ctx, req)
	}

	userid, err := toolrpc.GetUserIdKey(ctx)
	if err != nil {
		return nil, err
	}
	newCtx := toolrpc.SetGrpcHeader(ctx, "userid", userid)
	return handler(newCtx, req)
}

func useridInterceptorStream(srv interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {
	ctx := stream.Context()
	userid, err := toolrpc.GetUserIdKey(ctx)
	if err != nil {
		return err
	}
	newCtx := toolrpc.SetGrpcHeader(ctx, "userid", userid)
	wrapped := toolrpc.WrapServerStream(stream)
	wrapped.WrappedContext = newCtx
	return handler(srv, wrapped)
}
